{"version":3,"sources":["webpack:///./node_modules/wicket/wicket.js","webpack:///./src/views/Route.vue","webpack:///src/views/Route.vue","webpack:///./src/views/Route.vue?cedd","webpack:///./src/views/Route.vue?d4d0"],"names":["root","factory","this","beginsWith","endsWith","Wkt","obj","_wrapped","str","sub","substring","length","delimiter","isArray","constructor","Array","trim","initializer","wrapVertices","regExes","_stripWhitespaceAndParens","fullStr","trimmed","noParens","replace","components","undefined","read","fromObject","prototype","isCollection","type","slice","sameCoords","a","b","x","y","result","hasOwnProperty","fromJson","deconstruct","call","isRectangle","toObject","config","construct","properties","toString","write","i","j","k","coords","iring","oring","toLowerCase","geometry","coordinates","push","toJson","cs","json","ring","rings","s","ogcTypes","exec","toUpperCase","join","bbox","concat","merge","wkt","prefix","TypeError","matches","typeStr","base","ingest","apply","crudeJson","test","console","log","name","message","JSON","parse","pieces","data","extract","point","String","multipoint","parts","linestring","multilinestring","polygon","multipolygon","box","geometrycollection","split","spaces","parseFloat","numeric","points","comma","multipoints","line","lines","doubleParenComma","parenComma","subcomponents","filter","n","x_cord","y_cord","polygons","render","_vm","_c","_self","staticClass","ref","staticStyle","attrs","zoom","center","layerOptions","tileLayerClass","geoJsonData","features","geoJsonOptions","_e","cities","areaList","keyWord","citySelect","currArea","searchCardShow","on","$event","searchShapeData","cleanAreaSelect","toggleSearchCard","scopedSlots","_u","key","fn","_v","proxy","staticRenderFns","window","mapboxgl","SearchCard","LGeoJson","computed","mapState","mapGetters","isMobile","routesData","find","item","CityEngName","AreaList","get","areaSelect","set","val","$store","commit","position","long","lat","map","url","options","L","mapboxGL","accessToken","style","attribution","tileSize","zoomOffset","weight","color","onEachFeature","feature","layer","bindPopup","city","start","end","cyclingLength","minWidth","methods","loadBikeShapeData","dispatch","keyword","then","catch","err","polyRouteLine","forEach","r","Geometry","RouteName","City","RoadSectionStart","RoadSectionEnd","CyclingLength","flyTo","animate","getLocationCity","axios","res","ctyName","townName","enCity","CityName","AreaName","mounted","$nextTick","$refs","mapObject","navigator","geolocation","getCurrentPosition","latitude","longitude","watch","deep","handler","noData","alert","component"],"mappings":"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","file":"js/chunk-6d657f36.81d6356b.js","sourcesContent":["/** @license\n *\n *  Copyright (C) 2012 K. Arthur Endsley (kaendsle@mtu.edu)\n *  Michigan Tech Research Institute (MTRI)\n *  3600 Green Court, Suite 100, Ann Arbor, MI, 48105\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n(function (root, factory) {\n\n    if (typeof define === \"function\" && define.amd) {\n        // AMD (+ global for extensions)\n        define(function () {\n            return factory();\n        });\n    } else if (typeof module !== 'undefined' && typeof exports === \"object\") {\n        // CommonJS\n        module.exports = factory();\n    } else {\n        // Browser\n        root.Wkt = factory();\n    }\n}(this, function () {\n\n\n    var beginsWith, endsWith, root, Wkt;\n\n    // Establish the root object, window in the browser, or exports on the server\n    root = this;\n\n    /**\n     * @desc The Wkt namespace.\n     * @property    {String}    delimiter   - The default delimiter for separating components of atomic geometry (coordinates)\n     * @namespace\n     * @global\n     */\n    Wkt = function (obj) {\n        if (obj instanceof Wkt) return obj;\n        if (!(this instanceof Wkt)) return new Wkt(obj);\n        this._wrapped = obj;\n    };\n\n\n\n    /**\n     * Returns true if the substring is found at the beginning of the string.\n     * @param   str {String}    The String to search\n     * @param   sub {String}    The substring of interest\n     * @return      {Boolean}\n     * @private\n     */\n    beginsWith = function (str, sub) {\n        return str.substring(0, sub.length) === sub;\n    };\n\n    /**\n     * Returns true if the substring is found at the end of the string.\n     * @param   str {String}    The String to search\n     * @param   sub {String}    The substring of interest\n     * @return      {Boolean}\n     * @private\n     */\n    endsWith = function (str, sub) {\n        return str.substring(str.length - sub.length) === sub;\n    };\n\n    /**\n     * The default delimiter for separating components of atomic geometry (coordinates)\n     * @ignore\n     */\n    Wkt.delimiter = ' ';\n\n    /**\n     * Determines whether or not the passed Object is an Array.\n     * @param   obj {Object}    The Object in question\n     * @return      {Boolean}\n     * @member Wkt.isArray\n     * @method\n     */\n    Wkt.isArray = function (obj) {\n        return !!(obj && obj.constructor === Array);\n    };\n\n    /**\n     * Removes given character String(s) from a String.\n     * @param   str {String}    The String to search\n     * @param   sub {String}    The String character(s) to trim\n     * @return      {String}    The trimmed string\n     * @member Wkt.trim\n     * @method\n     */\n    Wkt.trim = function (str, sub) {\n        sub = sub || ' '; // Defaults to trimming spaces\n        // Trim beginning spaces\n        while (beginsWith(str, sub)) {\n            str = str.substring(1);\n        }\n        // Trim ending spaces\n        while (endsWith(str, sub)) {\n            str = str.substring(0, str.length - 1);\n        }\n        return str;\n    };\n\n    /**\n     * An object for reading WKT strings and writing geographic features\n     * @constructor this.Wkt.Wkt\n     * @param   initializer {String}    An optional WKT string for immediate read\n     * @property            {Array}     components      - Holder for atomic geometry objects (internal representation of geometric components)\n     * @property            {String}    delimiter       - The default delimiter for separating components of atomic geometry (coordinates)\n     * @property            {Object}    regExes         - Some regular expressions copied from OpenLayers.Format.WKT.js\n     * @property            {String}    type            - The Well-Known Text name (e.g. 'point') of the geometry\n     * @property            {Boolean}   wrapVerticies   - True to wrap vertices in MULTIPOINT geometries; If true: MULTIPOINT((30 10),(10 30),(40 40)); If false: MULTIPOINT(30 10,10 30,40 40)\n     * @return              {this.Wkt.Wkt}\n     * @memberof Wkt\n     */\n    Wkt.Wkt = function (initializer) {\n\n        /**\n         * The default delimiter between X and Y coordinates.\n         * @ignore\n         */\n        this.delimiter = Wkt.delimiter || ' ';\n\n        /**\n         * Configuration parameter for controlling how Wicket seralizes\n         * MULTIPOINT strings. Examples; both are valid WKT:\n         * If true: MULTIPOINT((30 10),(10 30),(40 40))\n         * If false: MULTIPOINT(30 10,10 30,40 40)\n         * @ignore\n         */\n        this.wrapVertices = true;\n\n        /**\n         * Some regular expressions copied from OpenLayers.Format.WKT.js\n         * @ignore\n         */\n        this.regExes = {\n            'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n            'spaces': /\\s+|\\+/, // Matches the '+' or the empty space\n            'numeric': /-*\\d+(\\.*\\d+)?/,\n            'comma': /\\s*,\\s*/,\n            'parenComma': /\\)\\s*,\\s*\\(/,\n            'coord': /-*\\d+\\.*\\d+ -*\\d+\\.*\\d+/, // e.g. \"24 -14\"\n            'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/,\n            'ogcTypes': /^(multi)?(point|line|polygon|box)?(string)?$/i, // Captures e.g. \"Multi\",\"Line\",\"String\"\n            'crudeJson': /^{.*\"(type|coordinates|geometries|features)\":.*}$/ // Attempts to recognize JSON strings\n        };\n\n        /**\n         * Strip any whitespace and parens from front and back.\n         * This is the equivalent of s/^\\s*\\(?(.*)\\)?\\s*$/$1/ but without the risk of catastrophic backtracking.\n         * @param   str {String}\n         */\n        this._stripWhitespaceAndParens = function (fullStr) {\n            var trimmed = fullStr.trim();\n            var noParens = trimmed.replace(/^\\(?(.*?)\\)?$/, '$1');\n            return noParens;\n        };\n\n        /**\n         * The internal representation of geometry--the \"components\" of geometry.\n         * @ignore\n         */\n        this.components = undefined;\n\n        // An initial WKT string may be provided\n        if (initializer && typeof initializer === 'string') {\n            this.read(initializer);\n        } else if (initializer && typeof initializer !== undefined) {\n            this.fromObject(initializer);\n        }\n\n    };\n\n\n\n    /**\n     * Returns true if the internal geometry is a collection of geometries.\n     * @return  {Boolean}   Returns true when it is a collection\n     * @memberof this.Wkt.Wkt\n     * @method\n     */\n    Wkt.Wkt.prototype.isCollection = function () {\n        switch (this.type.slice(0, 5)) {\n            case 'multi':\n                // Trivial; any multi-geometry is a collection\n                return true;\n            case 'polyg':\n                // Polygons with holes are \"collections\" of rings\n                return true;\n            default:\n                // Any other geometry is not a collection\n                return false;\n        }\n    };\n\n    /**\n     * Compares two x,y coordinates for equality.\n     * @param   a   {Object}    An object with x and y properties\n     * @param   b   {Object}    An object with x and y properties\n     * @return      {Boolean}\n     * @memberof this.Wkt.Wkt\n     * @method\n     */\n    Wkt.Wkt.prototype.sameCoords = function (a, b) {\n        return (a.x === b.x && a.y === b.y);\n    };\n\n    /**\n     * Sets internal geometry (components) from framework geometry (e.g.\n     * Google Polygon objects or google.maps.Polygon).\n     * @param   obj {Object}    The framework-dependent geometry representation\n     * @return      {this.Wkt.Wkt}   The object itself\n     * @memberof this.Wkt.Wkt\n     * @method\n     */\n    Wkt.Wkt.prototype.fromObject = function (obj) {\n        var result;\n\n        if (obj.hasOwnProperty('type') && obj.hasOwnProperty('coordinates')) {\n            result = this.fromJson(obj);\n        } else {\n            result = this.deconstruct.call(this, obj);\n        }\n\n        this.components = result.components;\n        this.isRectangle = result.isRectangle || false;\n        this.type = result.type;\n        return this;\n    };\n\n    /**\n     * Creates external geometry objects based on a plug-in framework's\n     * construction methods and available geometry classes.\n     * @param   config  {Object}    An optional framework-dependent properties specification\n     * @return          {Object}    The framework-dependent geometry representation\n     * @memberof this.Wkt.Wkt\n     * @method\n     */\n    Wkt.Wkt.prototype.toObject = function (config) {\n        var obj = this.construct[this.type].call(this, config);\n        // Don't assign the \"properties\" property to an Array\n        if (typeof obj === 'object' && !Wkt.isArray(obj)) {\n            obj.properties = this.properties;\n        }\n        return obj;\n    };\n\n    /**\n     * Returns the WKT string representation; the same as the write() method.\n     * @memberof this.Wkt.Wkt\n     * @method\n     */\n    Wkt.Wkt.prototype.toString = function (config) {\n        return this.write();\n    };\n\n    /**\n     * Parses a JSON representation as an Object.\n     * @param\tobj\t{Object}\tAn Object with the GeoJSON schema\n     * @return\t{this.Wkt.Wkt}\tThe object itself\n     * @memberof this.Wkt.Wkt\n     * @method\n     */\n    Wkt.Wkt.prototype.fromJson = function (obj) {\n        var i, j, k, coords, iring, oring;\n\n        this.type = obj.type.toLowerCase();\n        this.components = [];\n        if (obj.hasOwnProperty('geometry')) { //Feature\n            this.fromJson(obj.geometry);\n            this.properties = obj.properties;\n            return this;\n        }\n        coords = obj.coordinates;\n\n        if (!Wkt.isArray(coords[0])) { // Point\n            this.components.push({\n                x: coords[0],\n                y: coords[1]\n            });\n\n        } else {\n\n            for (i in coords) {\n                if (coords.hasOwnProperty(i)) {\n\n                    if (!Wkt.isArray(coords[i][0])) { // LineString\n\n                        if (this.type === 'multipoint') { // MultiPoint\n                            this.components.push([{\n                                x: coords[i][0],\n                                y: coords[i][1]\n                            }]);\n\n                        } else {\n                            this.components.push({\n                                x: coords[i][0],\n                                y: coords[i][1]\n                            });\n\n                        }\n\n                    } else {\n\n                        oring = [];\n                        for (j in coords[i]) {\n                            if (coords[i].hasOwnProperty(j)) {\n\n                                if (!Wkt.isArray(coords[i][j][0])) {\n                                    oring.push({\n                                        x: coords[i][j][0],\n                                        y: coords[i][j][1]\n                                    });\n\n                                } else {\n\n                                    iring = [];\n                                    for (k in coords[i][j]) {\n                                        if (coords[i][j].hasOwnProperty(k)) {\n\n                                            iring.push({\n                                                x: coords[i][j][k][0],\n                                                y: coords[i][j][k][1]\n                                            });\n\n                                        }\n                                    }\n\n                                    oring.push(iring);\n\n                                }\n\n                            }\n                        }\n\n                        this.components.push(oring);\n                    }\n                }\n            }\n\n        }\n\n        return this;\n    };\n\n    /**\n     * Creates a JSON representation, with the GeoJSON schema, of the geometry.\n     * @return    {Object}    The corresponding GeoJSON representation\n     * @memberof this.Wkt.Wkt\n     * @method\n     */\n    Wkt.Wkt.prototype.toJson = function () {\n        var cs, json, i, j, k, ring, rings;\n\n        cs = this.components;\n        json = {\n            coordinates: [],\n            type: (function () {\n                var i, type, s;\n\n                type = this.regExes.ogcTypes.exec(this.type).slice(1);\n                s = [];\n\n                for (i in type) {\n                    if (type.hasOwnProperty(i)) {\n                        if (type[i] !== undefined) {\n                            s.push(type[i].toLowerCase().slice(0, 1).toUpperCase() + type[i].toLowerCase().slice(1));\n                        }\n                    }\n                }\n\n                return s;\n            }.call(this)).join('')\n        }\n\n        // Wkt BOX type gets a special bbox property in GeoJSON\n        if (this.type.toLowerCase() === 'box') {\n            json.type = 'Polygon';\n            json.bbox = [];\n\n            for (i in cs) {\n                if (cs.hasOwnProperty(i)) {\n                    json.bbox = json.bbox.concat([cs[i].x, cs[i].y]);\n                }\n            }\n\n            json.coordinates = [\n                [\n                    [cs[0].x, cs[0].y],\n                    [cs[0].x, cs[1].y],\n                    [cs[1].x, cs[1].y],\n                    [cs[1].x, cs[0].y],\n                    [cs[0].x, cs[0].y]\n                ]\n            ];\n\n            return json;\n        }\n\n        // For the coordinates of most simple features\n        for (i in cs) {\n            if (cs.hasOwnProperty(i)) {\n\n                // For those nested structures\n                if (Wkt.isArray(cs[i])) {\n                    rings = [];\n\n                    for (j in cs[i]) {\n                        if (cs[i].hasOwnProperty(j)) {\n\n                            if (Wkt.isArray(cs[i][j])) { // MULTIPOLYGONS\n                                ring = [];\n\n                                for (k in cs[i][j]) {\n                                    if (cs[i][j].hasOwnProperty(k)) {\n                                        ring.push([cs[i][j][k].x, cs[i][j][k].y]);\n                                    }\n                                }\n\n                                rings.push(ring);\n\n                            } else { // POLYGONS and MULTILINESTRINGS\n\n                                if (cs[i].length > 1) {\n                                    rings.push([cs[i][j].x, cs[i][j].y]);\n\n                                } else { // MULTIPOINTS\n                                    rings = rings.concat([cs[i][j].x, cs[i][j].y]);\n                                }\n                            }\n                        }\n                    }\n\n                    json.coordinates.push(rings);\n\n                } else {\n                    if (cs.length > 1) { // For LINESTRING type\n                        json.coordinates.push([cs[i].x, cs[i].y]);\n\n                    } else { // For POINT type\n                        json.coordinates = json.coordinates.concat([cs[i].x, cs[i].y]);\n                    }\n                }\n\n            }\n        }\n\n        return json;\n    };\n\n    /**\n     * Absorbs the geometry of another this.Wkt.Wkt instance, merging it with its own,\n     * creating a collection (MULTI-geometry) based on their types, which must agree.\n     * For example, creates a MULTIPOLYGON from a POLYGON type merged with another\n     * POLYGON type, or adds a POLYGON instance to a MULTIPOLYGON instance.\n     * @param   wkt {String}    A Wkt.Wkt object\n     * @return\t{this.Wkt.Wkt}\tThe object itself\n     * @memberof this.Wkt.Wkt\n     * @method\n     */\n    Wkt.Wkt.prototype.merge = function (wkt) {\n        var prefix = this.type.slice(0, 5);\n\n        if (this.type !== wkt.type) {\n            if (this.type.slice(5, this.type.length) !== wkt.type) {\n                throw TypeError('The input geometry types must agree or the calling this.Wkt.Wkt instance must be a multigeometry of the other');\n            }\n        }\n\n        switch (prefix) {\n\n            case 'point':\n                this.components = [this.components.concat(wkt.components)];\n                break;\n\n            case 'multi':\n                this.components = this.components.concat((wkt.type.slice(0, 5) === 'multi') ? wkt.components : [wkt.components]);\n                break;\n\n            default:\n                this.components = [\n                    this.components,\n                    wkt.components\n                ];\n                break;\n\n        }\n\n        if (prefix !== 'multi') {\n            this.type = 'multi' + this.type;\n        }\n        return this;\n    };\n\n    /**\n     * Reads a WKT string, validating and incorporating it.\n     * @param   str {String}    A WKT or GeoJSON string\n     * @return\t{this.Wkt.Wkt}\tThe object itself\n     * @memberof this.Wkt.Wkt\n     * @method\n     */\n    Wkt.Wkt.prototype.read = function (str) {\n        var matches;\n        matches = this.regExes.typeStr.exec(str);\n        if (matches) {\n            this.type = matches[1].toLowerCase();\n            this.base = matches[2];\n            if (this.ingest[this.type]) {\n                this.components = this.ingest[this.type].apply(this, [this.base]);\n            }\n\n        } else {\n            if (this.regExes.crudeJson.test(str)) {\n                if (typeof JSON === 'object' && typeof JSON.parse === 'function') {\n                    this.fromJson(JSON.parse(str));\n\n                } else {\n                    console.log('JSON.parse() is not available; cannot parse GeoJSON strings');\n                    throw {\n                        name: 'JSONError',\n                        message: 'JSON.parse() is not available; cannot parse GeoJSON strings'\n                    };\n                }\n\n            } else {\n                console.log('Invalid WKT string provided to read()');\n                throw {\n                    name: 'WKTError',\n                    message: 'Invalid WKT string provided to read()'\n                };\n            }\n        }\n\n        return this;\n    }; // eo readWkt\n\n    /**\n     * Writes a WKT string.\n     * @param   components  {Array}     An Array of internal geometry objects\n     * @return              {String}    The corresponding WKT representation\n     * @memberof this.Wkt.Wkt\n     * @method\n     */\n    Wkt.Wkt.prototype.write = function (components) {\n        var i, pieces, data;\n\n        components = components || this.components;\n\n        pieces = [];\n\n        pieces.push(this.type.toUpperCase() + '(');\n\n        for (i = 0; i < components.length; i += 1) {\n            if (this.isCollection() && i > 0) {\n                pieces.push(',');\n            }\n\n            // There should be an extract function for the named type\n            if (!this.extract[this.type]) {\n                return null;\n            }\n\n            data = this.extract[this.type].apply(this, [components[i]]);\n            if (this.isCollection() && this.type !== 'multipoint') {\n                pieces.push('(' + data + ')');\n\n            } else {\n                pieces.push(data);\n\n                // If not at the end of the components, add a comma\n                if (i !== (components.length - 1) && this.type !== 'multipoint') {\n                    pieces.push(',');\n                }\n\n            }\n        }\n\n        pieces.push(')');\n\n        return pieces.join('');\n    };\n\n    /**\n     * This object contains functions as property names that extract WKT\n     * strings from the internal representation.\n     * @memberof this.Wkt.Wkt\n     * @namespace this.Wkt.Wkt.extract\n     * @instance\n     */\n    Wkt.Wkt.prototype.extract = {\n        /**\n         * Return a WKT string representing atomic (point) geometry\n         * @param   point   {Object}    An object with x and y properties\n         * @return          {String}    The WKT representation\n         * @memberof this.Wkt.Wkt.extract\n         * @instance\n         */\n        point: function (point) {\n            return String(point.x) + this.delimiter + String(point.y);\n        },\n\n        /**\n         * Return a WKT string representing multiple atoms (points)\n         * @param   multipoint  {Array}     Multiple x-and-y objects\n         * @return              {String}    The WKT representation\n         * @memberof this.Wkt.Wkt.extract\n         * @instance\n         */\n        multipoint: function (multipoint) {\n            var i, parts = [],\n                s;\n\n            for (i = 0; i < multipoint.length; i += 1) {\n                s = this.extract.point.apply(this, [multipoint[i]]);\n\n                if (this.wrapVertices) {\n                    s = '(' + s + ')';\n                }\n\n                parts.push(s);\n            }\n\n            return parts.join(',');\n        },\n\n        /**\n         * Return a WKT string representing a chain (linestring) of atoms\n         * @param   linestring  {Array}     Multiple x-and-y objects\n         * @return              {String}    The WKT representation\n         * @memberof this.Wkt.Wkt.extract\n         * @instance\n         */\n        linestring: function (linestring) {\n            // Extraction of linestrings is the same as for points\n            return this.extract.point.apply(this, [linestring]);\n        },\n\n        /**\n         * Return a WKT string representing multiple chains (multilinestring) of atoms\n         * @param   multilinestring {Array}     Multiple of multiple x-and-y objects\n         * @return                  {String}    The WKT representation\n         * @memberof this.Wkt.Wkt.extract\n         * @instance\n         */\n        multilinestring: function (multilinestring) {\n            var i, parts = [];\n\n            if (multilinestring.length) {\n                for (i = 0; i < multilinestring.length; i += 1) {\n                    parts.push(this.extract.linestring.apply(this, [multilinestring[i]]));\n                }\n            } else {\n                parts.push(this.extract.point.apply(this, [multilinestring]));\n            }\n\n            return parts.join(',');\n        },\n\n        /**\n         * Return a WKT string representing multiple atoms in closed series (polygon)\n         * @param   polygon {Array}     Collection of ordered x-and-y objects\n         * @return          {String}    The WKT representation\n         * @memberof this.Wkt.Wkt.extract\n         * @instance\n         */\n        polygon: function (polygon) {\n            // Extraction of polygons is the same as for multilinestrings\n            return this.extract.multilinestring.apply(this, [polygon]);\n        },\n\n        /**\n         * Return a WKT string representing multiple closed series (multipolygons) of multiple atoms\n         * @param   multipolygon    {Array}     Collection of ordered x-and-y objects\n         * @return                  {String}    The WKT representation\n         * @memberof this.Wkt.Wkt.extract\n         * @instance\n         */\n        multipolygon: function (multipolygon) {\n            var i, parts = [];\n            for (i = 0; i < multipolygon.length; i += 1) {\n                parts.push('(' + this.extract.polygon.apply(this, [multipolygon[i]]) + ')');\n            }\n            return parts.join(',');\n        },\n\n        /**\n         * Return a WKT string representing a 2DBox\n         * @param   multipolygon    {Array}     Collection of ordered x-and-y objects\n         * @return                  {String}    The WKT representation\n         * @memberof this.Wkt.Wkt.extract\n         * @instance\n         */\n        box: function (box) {\n            return this.extract.linestring.apply(this, [box]);\n        },\n\n        geometrycollection: function (str) {\n            console.log('The geometrycollection WKT type is not yet supported.');\n        }\n    };\n\n    /**\n     * This object contains functions as property names that ingest WKT\n     * strings into the internal representation.\n     * @memberof this.Wkt.Wkt\n     * @namespace this.Wkt.Wkt.ingest\n     * @instance\n     */\n    Wkt.Wkt.prototype.ingest = {\n\n        /**\n         * Return point feature given a point WKT fragment.\n         * @param   str {String}    A WKT fragment representing the point\n         * @memberof this.Wkt.Wkt.ingest\n         * @instance\n         */\n        point: function (str) {\n            var coords = Wkt.trim(str).split(this.regExes.spaces);\n            // In case a parenthetical group of coordinates is passed...\n            return [{ // ...Search for numeric substrings\n                x: parseFloat(this.regExes.numeric.exec(coords[0])[0]),\n                y: parseFloat(this.regExes.numeric.exec(coords[1])[0])\n            }];\n        },\n\n        /**\n         * Return a multipoint feature given a multipoint WKT fragment.\n         * @param   str {String}    A WKT fragment representing the multipoint\n         * @memberof this.Wkt.Wkt.ingest\n         * @instance\n         */\n        multipoint: function (str) {\n            var i, components, points;\n            components = [];\n            points = Wkt.trim(str).split(this.regExes.comma);\n            for (i = 0; i < points.length; i += 1) {\n                components.push(this.ingest.point.apply(this, [points[i]]));\n            }\n            return components;\n        },\n\n        /**\n         * Return a linestring feature given a linestring WKT fragment.\n         * @param   str {String}    A WKT fragment representing the linestring\n         * @memberof this.Wkt.Wkt.ingest\n         * @instance\n         */\n        linestring: function (str) {\n            var i, multipoints, components;\n\n            // In our x-and-y representation of components, parsing\n            //  multipoints is the same as parsing linestrings\n            multipoints = this.ingest.multipoint.apply(this, [str]);\n\n            // However, the points need to be joined\n            components = [];\n            for (i = 0; i < multipoints.length; i += 1) {\n                components = components.concat(multipoints[i]);\n            }\n            return components;\n        },\n\n        /**\n         * Return a multilinestring feature given a multilinestring WKT fragment.\n         * @param   str {String}    A WKT fragment representing the multilinestring\n         * @memberof this.Wkt.Wkt.ingest\n         * @instance\n         */\n        multilinestring: function (str) {\n            var i, components, line, lines;\n            components = [];\n\n            lines = Wkt.trim(str).split(this.regExes.doubleParenComma);\n            if (lines.length === 1) { // If that didn't work...\n                lines = Wkt.trim(str).split(this.regExes.parenComma);\n            }\n\n            for (i = 0; i < lines.length; i += 1) {\n                line = this._stripWhitespaceAndParens(lines[i]);\n                components.push(this.ingest.linestring.apply(this, [line]));\n            }\n\n            return components;\n        },\n\n        /**\n         * Return a polygon feature given a polygon WKT fragment.\n         * @param   str {String}    A WKT fragment representing the polygon\n         * @memberof this.Wkt.Wkt.ingest\n         * @instance\n         */\n        polygon: function (str) {\n            var i, j, components, subcomponents, ring, rings;\n            rings = Wkt.trim(str).split(this.regExes.parenComma);\n            components = []; // Holds one or more rings\n            for (i = 0; i < rings.length; i += 1) {\n                ring = this._stripWhitespaceAndParens(rings[i]).split(this.regExes.comma);\n                subcomponents = []; // Holds the outer ring and any inner rings (holes)\n                for (j = 0; j < ring.length; j += 1) {\n                    // Split on the empty space or '+' character (between coordinates)\n                    var split = ring[j].split(this.regExes.spaces);\n                    if (split.length > 2) {\n                        //remove the elements which are blanks\n                        split = split.filter(function (n) {\n                            return n != \"\"\n                        });\n                    }\n                    if (split.length === 2) {\n                        var x_cord = split[0];\n                        var y_cord = split[1];\n\n                        //now push\n                        subcomponents.push({\n                            x: parseFloat(x_cord),\n                            y: parseFloat(y_cord)\n                        });\n                    }\n                }\n                components.push(subcomponents);\n            }\n            return components;\n        },\n\n        /**\n         * Return box vertices (which would become the Rectangle bounds) given a Box WKT fragment.\n         * @param   str {String}    A WKT fragment representing the box\n         * @memberof this.Wkt.Wkt.ingest\n         * @instance\n         */\n        box: function (str) {\n            var i, multipoints, components;\n\n            // In our x-and-y representation of components, parsing\n            //  multipoints is the same as parsing linestrings\n            multipoints = this.ingest.multipoint.apply(this, [str]);\n\n            // However, the points need to be joined\n            components = [];\n            for (i = 0; i < multipoints.length; i += 1) {\n                components = components.concat(multipoints[i]);\n            }\n\n            return components;\n        },\n\n        /**\n         * Return a multipolygon feature given a multipolygon WKT fragment.\n         * @param   str {String}    A WKT fragment representing the multipolygon\n         * @memberof this.Wkt.Wkt.ingest\n         * @instance\n         */\n        multipolygon: function (str) {\n            var i, components, polygon, polygons;\n            components = [];\n            polygons = Wkt.trim(str).split(this.regExes.doubleParenComma);\n            for (i = 0; i < polygons.length; i += 1) {\n                polygon = this._stripWhitespaceAndParens(polygons[i]);\n                components.push(this.ingest.polygon.apply(this, [polygon]));\n            }\n            return components;\n        },\n\n        /**\n         * Return an array of features given a geometrycollection WKT fragment.\n         * @param   str {String}    A WKT fragment representing the geometry collection\n         * @memberof this.Wkt.Wkt.ingest\n         * @instance\n         */\n        geometrycollection: function (str) {\n            console.log('The geometrycollection WKT type is not yet supported.');\n        }\n\n    }; // eo ingest\n\n    return Wkt;\n}));\n","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"container-fluid position-relative px-0\"},[_c('LMap',{ref:\"map\",staticClass:\"w-100\",staticStyle:{\"height\":\"calc(100vh - 100px)\"},attrs:{\"id\":\"map\",\"zoom\":_vm.zoom,\"center\":_vm.center,\"zoomAnimation\":true,\"max-zoom\":19}},[_c('LTileLayer',{attrs:{\"options\":_vm.layerOptions,\"tile-layer-class\":_vm.tileLayerClass}}),(_vm.geoJsonData.features.length)?_c('LGeoJson',{attrs:{\"geojson\":_vm.geoJsonData,\"options\":_vm.geoJsonOptions}}):_vm._e()],1),_c('SearchCard',{attrs:{\"cities\":_vm.cities,\"areaList\":_vm.areaList,\"key-word\":_vm.keyWord,\"city-select\":_vm.citySelect,\"area-select\":_vm.currArea,\"inputPlaceholder\":'請輸入路線關鍵字(非必填)',\"searchCardShow\":_vm.searchCardShow},on:{\"update:keyWord\":[function($event){_vm.keyWord=$event},function($event){_vm.keyWord = $event}],\"update:key-word\":function($event){_vm.keyWord=$event},\"update:citySelect\":function($event){_vm.citySelect=$event},\"update:city-select\":function($event){_vm.citySelect=$event},\"update:areaSelect\":function($event){_vm.currArea=$event},\"update:area-select\":function($event){_vm.currArea=$event},\"loadCityData\":_vm.searchShapeData,\"cleanAreaSelect\":_vm.cleanAreaSelect,\"toggleSearchCard\":_vm.toggleSearchCard},scopedSlots:_vm._u([{key:\"title\",fn:function(){return [_c('h2',{staticClass:\"card-title letter-5\"},[_vm._v(\"路線搜尋\")])]},proxy:true}])})],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n  <div class=\"container-fluid position-relative px-0\">\r\n    <LMap\r\n      ref=\"map\"\r\n      id=\"map\"\r\n      :zoom=\"zoom\"\r\n      :center=\"center\"\r\n      :zoomAnimation=\"true\"\r\n      class=\"w-100\"\r\n      style=\"height: calc(100vh - 100px)\"\r\n      :max-zoom=\"19\"\r\n    >\r\n      <LTileLayer :options=\"layerOptions\" :tile-layer-class=\"tileLayerClass\" />\r\n      <LGeoJson\r\n        :geojson=\"geoJsonData\"\r\n        :options=\"geoJsonOptions\"\r\n        v-if=\"geoJsonData.features.length\"\r\n      />\r\n    </LMap>\r\n\r\n    <SearchCard\r\n      :cities=\"cities\"\r\n      :areaList=\"areaList\"\r\n      :key-word.sync=\"keyWord\"\r\n      :city-select.sync=\"citySelect\"\r\n      :area-select.sync=\"currArea\"\r\n      :inputPlaceholder=\"'請輸入路線關鍵字(非必填)'\"\r\n      @update:keyWord=\"keyWord = $event\"\r\n      @loadCityData=\"searchShapeData\"\r\n      @cleanAreaSelect=\"cleanAreaSelect\"\r\n      @toggleSearchCard=\"toggleSearchCard\"\r\n      :searchCardShow=\"searchCardShow\"\r\n    >\r\n      <template v-slot:title>\r\n        <h2 class=\"card-title letter-5\">路線搜尋</h2>\r\n      </template>\r\n    </SearchCard>\r\n  </div>\r\n</template>\r\n<script>\r\nimport L from 'leaflet'\r\nimport { LGeoJson } from 'vue2-leaflet'\r\nimport mapboxgl from 'mapbox-gl'\r\nimport 'mapbox-gl-leaflet'\r\nimport 'mapbox-gl/dist/mapbox-gl.css'\r\nimport 'leaflet/dist/leaflet.css'\r\nimport Wkt from 'wicket'\r\nimport { mapState, mapGetters } from 'vuex'\r\nimport SearchCard from '@/components/SearchCard.vue'\r\nwindow.mapboxgl = mapboxgl\r\n\r\nexport default {\r\n  name: 'Route',\r\n  components: {\r\n    SearchCard,\r\n    LGeoJson\r\n  },\r\n  computed: {\r\n    ...mapState(['cities']),\r\n    ...mapState('route', ['areaSelect', 'noData']),\r\n    ...mapGetters({\r\n      isMobile: 'isMobile',\r\n      routesData: 'route/filteredRoutes'\r\n    }),\r\n    areaList () {\r\n      return this.cities.find((item) => item.CityEngName === this.citySelect)\r\n        .AreaList\r\n    },\r\n    currArea: {\r\n      get () {\r\n        return this.areaSelect\r\n      },\r\n      set (val) {\r\n        this.$store.commit('route/SET_AREA_SELECT', val)\r\n      }\r\n    },\r\n    center () {\r\n      const [position] = this.geoJsonData.features\r\n      if (!!position && position) {\r\n        const [long, lat] = position.geometry.coordinates[0][0]\r\n        return [lat, long]\r\n      } else {\r\n        return [23.58259486, 120.58552886]\r\n      }\r\n    }\r\n  },\r\n  data () {\r\n    return {\r\n      map: null,\r\n      zoom: 13,\r\n      tileLayerClass: (url, options) => L.mapboxGL(options),\r\n      layerOptions: {\r\n        accessToken:\r\n          'pk.eyJ1IjoiaHNpbmh1aSIsImEiOiJja3Z3NnFrejIwNWd6Mm9uMDNiNGJ0bGxkIn0.xezbS4RWCo5XLQQLjZVc_g',\r\n        style: 'mapbox://styles/mapbox/streets-v11',\r\n        attribution:\r\n          'Map data &copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors, Imagery © <a href=\"https://www.mapbox.com/\">Mapbox</a>',\r\n        tileSize: 512,\r\n        zoomOffset: -1\r\n      },\r\n      keyWord: '',\r\n      citySelect: 'Taipei',\r\n      geoJsonData: {\r\n        features: []\r\n      },\r\n      geoJsonOptions: {\r\n        style: function () {\r\n          return {\r\n            weight: 7,\r\n            color: '#0D706D'\r\n          }\r\n        },\r\n        onEachFeature: function (feature, layer) {\r\n          const properties = feature.properties\r\n          layer.bindPopup(\r\n            `\r\n           <div class=\"card popup\">\r\n              <div class=\"card-body\">\r\n                <h3>${properties.name}</h3>\r\n                <p>${properties.city}</p>\r\n                <p>${properties.start} - ${properties.end}</p>\r\n                <p>全長: ${properties.cyclingLength}</p>\r\n              </div>\r\n            </div>\r\n          `,\r\n            { minWidth: 250 }\r\n          )\r\n        }\r\n      },\r\n      searchCardShow: true\r\n    }\r\n  },\r\n  methods: {\r\n    loadBikeShapeData (city = this.citySelect) {\r\n      this.$store.dispatch('setIsLoading', true)\r\n      return this.$store\r\n        .dispatch('route/getCityRouteShape', {\r\n          city,\r\n          keyword: this.keyWord\r\n        })\r\n        .then(() => {\r\n          this.$store.dispatch('setIsLoading', false)\r\n        })\r\n        .catch((err) => {\r\n          this.$store.dispatch('setIsLoading', false)\r\n          console.log(err)\r\n        })\r\n    },\r\n    polyRouteLine () {\r\n      const wkt = new Wkt.Wkt()\r\n      this.geoJsonData = { features: [] }\r\n      this.routesData.forEach((r) => {\r\n        this.geoJsonData.features.push({\r\n          type: 'Feature',\r\n          geometry: wkt.read(r.Geometry).toJson(),\r\n          properties: {\r\n            name: r.RouteName,\r\n            city: r.City,\r\n            start: r.RoadSectionStart ? r.RoadSectionStart : '無提供起點',\r\n            end: r.RoadSectionEnd ? r.RoadSectionEnd : '無提供終點',\r\n            cyclingLength: r.CyclingLength ? `${r.CyclingLength} m` : '-'\r\n          }\r\n        })\r\n      })\r\n    },\r\n    searchShapeData () {\r\n      return this.loadBikeShapeData().then(() => {\r\n        this.map.flyTo(this.center, 10, {\r\n          animate: true\r\n        })\r\n        if (this.isMobile) this.searchCardShow = false\r\n      })\r\n    },\r\n    getLocationCity (lat, long) {\r\n      return this.axios\r\n        .get(\r\n          `https://api.nlsc.gov.tw/other/TownVillagePointQuery/${long}/${lat}`\r\n        )\r\n        .then((res) => {\r\n          const { ctyName, townName } = res.data\r\n          const enCity = this.cities.find((item) => {\r\n            return item.CityName === ctyName\r\n          })\r\n          const currArea = enCity.AreaList.find((item) => {\r\n            return item.AreaName === townName\r\n          }).AreaName\r\n          this.citySelect = enCity.CityEngName\r\n          this.$store.commit('route/SET_AREA_SELECT', currArea)\r\n          return res\r\n        })\r\n    },\r\n    cleanAreaSelect () {\r\n      this.$store.commit('route/SET_AREA_SELECT', null)\r\n    },\r\n    toggleSearchCard () {\r\n      this.searchCardShow = !this.searchCardShow\r\n    }\r\n  },\r\n  mounted () {\r\n    this.$nextTick(() => {\r\n      this.map = this.$refs.map.mapObject\r\n      navigator.geolocation.getCurrentPosition((position) => {\r\n        const { latitude, longitude } = position.coords\r\n        this.getLocationCity(latitude, longitude).then(() => {\r\n          this.loadBikeShapeData(this.citySelect)\r\n        })\r\n      })\r\n    })\r\n  },\r\n  watch: {\r\n    routesData: {\r\n      deep: true,\r\n      handler () {\r\n        this.polyRouteLine()\r\n      }\r\n    },\r\n    noData (val) {\r\n      if (val) alert('查無路線')\r\n    }\r\n  }\r\n}\r\n</script>\r\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Route.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Route.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Route.vue?vue&type=template&id=58e2ea58\"\nimport script from \"./Route.vue?vue&type=script&lang=js\"\nexport * from \"./Route.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}